#!/usr/bin/env node

const { spawnSync } = require("node:child_process");
const { readFileSync, writeFileSync } = require("node:fs");
const { join, parse } = require("node:path");

/**
 * Check if current line is `! comment`
 * @param {string} line line to check
 */
function isComment(line) {
  return line[0] === "!";
}

/**
 * Check if current line is `:style()` rule
 * @param {string} line line to check
 */
function isStyle(line) {
  return line.includes(":style(");
}

/**
 * Check if current line is remove rule
 * @param {string} line line to check
 */
function isRule(line) {
  return !isComment(line) && !isStyle(line);
}

/**
 * Check if current text not newline \n
 * @param {string} text text to check
 */
function notNL(text) {
  return text !== "\n";
}

/**
 * Check if current line is `! Description:` comment
 * @param {string} line line to check
 */
function isDescription(line) {
  return line.includes("Description:");
}

/**
 * Check if current line is `! Last updated:` comment
 * @param {string} line line to check
 */
function isLastUpdated(line) {
  return line.includes("Last updated:");
}

/**
 * Check if current line is `! Title:` comment
 * @param {string} line line to check
 */
function isTitle(line) {
  return line.includes("Title:");
}

/**
 * load input file and split to lines
 * @param {string} path Input file path
 */
function loadFile(path) {
  return readFileSync(path, { encoding: "utf-8" }).split("\n").filter(notNL);
}

/**
 * Get meta comments from lines
 * @param {string[]} lines Lines
 * @param {string} timeStamp Current time string in ISO8601 format
 * @return meta comments
 */
function getMeta(lines, timeStamp) {
  return lines
    .map((line) => {
      return isTitle(line)
        ? `${line} minified`
        : isDescription(line) || isLastUpdated(line)
        ? line
        : "\n";
    })
    .filter(notNL)
    .concat(`! generated by rule-combiner ${timeStamp}`);
}

/**
 * Get remove rules from lines
 * @param {string} lines Lines
 * @return remove rules
 */
function getRules(lines) {
  return lines.filter(isRule);
}

/**
 * Get style rules from raw lines
 * @param {string[]} lines Lines
 * @return style rules
 */
function getStyles(lines) {
  return lines.filter(isStyle).map((line) => `${line}|`);
}

/**
 * Get style map from lines
 * @param {string[]} lines Lines
 * @return {Map<string, string[]>} Style Map
 */
function getStyleMap(lines) {
  const styleMap = new Map();
  lines.forEach((line) => {
    const [entity, style] = line.split(":style(");
    const oldStyles = styleMap.get(entity) ?? [];
    styleMap.set(entity, [...oldStyles, style.replaceAll(")|", "")]);
  });
  return styleMap;
}

/**
 * Get combined styles from lines
 * @param {string[]} lines Lines
 * @return Combined styles
 */
function getCombinedStyles(lines) {
  const styleMap = getStyleMap(lines);
  return Array.from(styleMap.keys()).map(
    (entity) => `${entity}:style(${(styleMap.get(entity) ?? []).join("; ")})`,
  );
}

/**
 * Get mobile header
 * @param {string} path Input file path
 * @return mobile header or empty string
 */
function getMobileHeader(path) {
  return path.includes("mobile") ? "!#if env_mobile" : "";
}

/**
 * Get mobile footer
 * @param {string} path Input file path
 * @return mobile footer or empty string
 */
function getMobileFooter(path) {
  return path.includes("mobile") ? "!#endif" : "";
}

/**
 * Get current timestamp
 * @return Current local time string in ISO8601 format
 */
function getTimeStamp() {
  return new Date(
    Date.now() - new Date().getTimezoneOffset() * 60000,
  ).toISOString();
}

/**
 * Get final processed rule lines
 * @param {string[]} lines Lines
 * @param {string} path Input file path
 * @return output line string
 */
function getOutputRules(lines, path) {
  return [
    ...getMeta(lines, getTimeStamp()),
    getMobileHeader(path),
    ...getRules(lines),
    ...getCombinedStyles(getStyles(lines)),
    getMobileFooter(path),
  ]
    .filter(Boolean)
    .join("\n")
    .concat("\n");
}

/**
 * Get output file path
 * @param {string} path Input file path
 * @return Output file path
 */
function getCombinedFilePath(path) {
  const p = parse(path);
  return join(p.dir, `${p.name}.min.txt`);
}

/**
 * Combine rules for all input files
 * @param {string} cwd current working directory
 * @param {string[]} files Input file names
 * @return Array<[Input file path, Combined file path]>
 */
function combineRules(cwd, files) {
  return files
    .map((file) => join(cwd, file))
    .map((inputFilePath) => {
      const inputLines = loadFile(inputFilePath);
      const combinedFilePath = getCombinedFilePath(inputFilePath);
      writeFileSync(
        combinedFilePath,
        getOutputRules(inputLines, inputFilePath),
      );
      return [inputFilePath, combinedFilePath];
    });
}

/**
 * Add files to git
 * @param {string} cwd current working directory
 * @param {string[][]} filePairs Array<[Input file path, Combined file path]>
 */
function addRules(cwd, filePairs) {
  filePairs.map(([inputFile, outputFile]) => {
    spawnSync("git", ["add", inputFile], { cwd });
    spawnSync("git", ["add", outputFile], { cwd });
  });
}

/**
 * Make a git commit
 * @param {string} cwd current working directory
 */
function commitRules(cwd) {
  spawnSync("git", ["commit", "-qm", "feat: update ubo-rules by urb"], { cwd });
}

/**
 * Make a git push
 * @param {string} cwd current working directory
 */
function pushRules(cwd) {
  spawnSync("git", ["push", "-q"], { cwd });
}

/**
 * main function
 */
function main() {
  const configDir = join(__dirname, "..", "configs");
  const filePairs = combineRules(configDir, [
    "ubo-desktop.txt",
    "ubo-mobile.txt",
    "ubo-font.txt",
  ]);
  addRules(configDir, filePairs);
  commitRules(configDir);
  pushRules(configDir);
}

main();
