#!/usr/bin/env node

const { spawnSync } = require("node:child_process");
const { readFileSync, writeFileSync } = require("node:fs");
const { join, parse } = require("node:path");

/**
 * Check if current line is `! comment`
 * @param {string} line line to check
 */
const isComment = (line) => line[0] === "!";

/**
 * Check if current line is `:style()` rule
 * @param {string} line line to check
 */
const isStyle = (line) => line.includes(":style(");

/**
 * Check if current line is remove rule
 * @param {string} line line to check
 */
const isRule = (line) => !isComment(line) && !isStyle(line);

/**
 * Check if current text not newline \n
 * @param {string} text text to check
 */
const notNL = (text) => text !== "\n";

/**
 * Check if current line is `! Description:` comment
 * @param {string} line line to check
 */
const isDescription = (line) => line.includes("Description:");

/**
 * Check if current line is `! Last updated:` comment
 * @param {string} line line to check
 */
const isLastUpdated = (line) => line.includes("Last updated:");

/**
 * Check if current line is `! Title:` comment
 * @param {string} line line to check
 */
const isTitle = (line) => line.includes("Title:");

/**
 * load input file and split to lines
 * @param {string} path Input file path
 */
const loadFile = (path) =>
  readFileSync(path, { encoding: "utf-8" }).split("\n").filter(notNL);

/**
 * Get meta comments from lines
 * @param {string[]} lines Lines
 * @param {string} timeStamp Current time string in ISO8601 format
 * @return meta comments
 */
const getMeta = (lines, timeStamp) =>
  lines
    .map((line) => {
      return isTitle(line)
        ? `${line} minified`
        : isDescription(line) || isLastUpdated(line)
        ? line
        : "\n";
    })
    .filter(notNL)
    .concat(`! generated by rule-combiner ${timeStamp}`);

/**
 * Get remove rules from lines
 * @param {string} lines Lines
 * @return remove rules
 */
const getRules = (lines) => lines.filter(isRule);

/**
 * Get style rules from raw lines
 * @param {string[]} lines Lines
 * @return style rules
 */
const getStyles = (lines) => lines.filter(isStyle).map((line) => `${line}|`);

/**
 * Get style map from lines
 * @param {string[]} lines Lines
 * @return {Map<string, string[]>} Style Map
 */
const getStyleMap = (lines) => {
  const styleMap = new Map();
  lines.forEach((line) => {
    const [entity, style] = line.split(":style(");
    const oldStyles = styleMap.get(entity) ?? [];
    styleMap.set(entity, [...oldStyles, style.replaceAll(")|", "")]);
  });
  return styleMap;
};

/**
 * Get combined styles from lines
 * @param {string[]} lines Lines
 * @return Combined styles
 */
const getCombinedStyles = (lines) => {
  const styleMap = getStyleMap(lines);
  return Array.from(styleMap.keys()).map(
    (entity) => `${entity}:style(${(styleMap.get(entity) ?? []).join("; ")})`,
  );
};

/**
 * Get mobile header
 * @param {string} path Input file path
 * @return mobile header or empty string
 */
const getMobileHeader = (path) =>
  path.includes("mobile") ? "!#if env_mobile" : "";

/**
 * Get mobile footer
 * @param {string} path Input file path
 * @return mobile footer or empty string
 */
const getMobileFooter = (path) => (path.includes("mobile") ? "!#endif" : "");

/**
 * Get current timestamp
 * @return Current local time string in ISO8601 format
 */
const getTimeStamp = () =>
  new Date(Date.now() - new Date().getTimezoneOffset() * 60000).toISOString();

/**
 * Get final processed rule lines
 * @param {string[]} lines Lines
 * @param {string} path Input file path
 * @return output line string
 */
const getOutputRules = (lines, path) =>
  [
    ...getMeta(lines, getTimeStamp()),
    getMobileHeader(path),
    ...getRules(lines),
    ...getCombinedStyles(getStyles(lines)),
    getMobileFooter(path),
  ]
    .filter(Boolean)
    .join("\n")
    .concat("\n");

/**
 * Get output file path
 * @param {string} path Input file path
 * @return Output file path
 */
const getCombinedFilePath = (path) => {
  const p = parse(path);
  return join(p.dir, `${p.name}.min.txt`);
};

/**
 * Combine rules for all input files
 * @param {string} cwd current working directory
 * @param {string[]} files Input file names
 * @return Array<[Input file path, Combined file path]>
 */
const combineRules = (cwd, files) =>
  files
    .map((file) => join(cwd, file))
    .map((inputFilePath) => {
      const inputLines = loadFile(inputFilePath);
      const combinedFilePath = getCombinedFilePath(inputFilePath);
      writeFileSync(
        combinedFilePath,
        getOutputRules(inputLines, inputFilePath),
      );
      return [inputFilePath, combinedFilePath];
    });

/**
 * Add files to git
 * @param {string} cwd current working directory
 * @param {string[][]} filePairs Array<[Input file path, Combined file path]>
 */
const addRules = (cwd, filePairs) => {
  filePairs.map(([inputFile, outputFile]) => {
    spawnSync("git", ["add", inputFile], { cwd });
    spawnSync("git", ["add", outputFile], { cwd });
  });
};

/**
 * Make a git commit
 * @param {string} cwd current working directory
 */
const commitRules = (cwd) => {
  spawnSync("git", ["commit", "-qm", "feat: update ubo-rules by urb"], { cwd });
};

/**
 * Make a git push
 * @param {string} cwd current working directory
 */
const pushRules = (cwd) => {
  spawnSync("git", ["push", "-q"], { cwd });
};

/**
 * main function
 */
const main = () => {
  const configDir = join(__dirname, "..", "configs");
  const filePairs = combineRules(configDir, [
    "ubo-desktop.txt",
    "ubo-mobile.txt",
    "ubo-font.txt",
  ]);
  addRules(configDir, filePairs);
  commitRules(configDir);
  pushRules(configDir);
};

main();
