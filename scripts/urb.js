/**
 * Check if current rule is `! comment`
 * @param {string} s
 * @returns {boolean}
 */
const isComment = (s) => s[0] === "!";

/**
 * Check if current rule is `:style()` rule
 * @param {string} s
 * @returns {boolean}
 */
const isStyle = (s) => s.includes(":style(");

/**
 * Check if current rule is remove rule
 * @param {string} s
 * @returns {boolean}
 */
const isRule = (s) => !isComment(s) && !isStyle(s);

/**
 * Check if current text not newline \n
 * @param {string} s
 * @returns {boolean}
 */
const notNL = (s) => s !== "\n";

/**
 * Check if current rule is `! Description:` comment
 * @param {string} s
 * @returns {boolean}
 */
const isDescription = (s) => s.includes("Description:");

/**
 * Check if current rule is `! Last updated:` comment
 * @param {string} s
 * @returns boolean
 */
const isLastUpdated = (s) => s.includes("Last updated:");

/**
 * Check if current rule is `! Title:` comment
 * @param {string} s
 * @returns {boolean}
 */
const isTitle = (s) => s.includes("Title:");

/**
 * load input file and split to lines
 * @param {string} path Input file path
 * @returns {Promise<string[]>}
 */
const loadFile = async (path) => {
  const s = await Bun.file(path).text();
  return s.split("\n").filter(notNL);
};

/**
 * Get meta comments from raw rules
 * @param {string[]} ss Raw Rules
 * @param {string} timeStamp Current time string in ISO8601 format
 * @returns {string[]} meta comments
 */
const getMeta = (ss, timeStamp) =>
  ss
    .map((s) => {
      return isTitle(s)
        ? `${s} minified`
        : isDescription(s) || isLastUpdated(s)
        ? s
        : "\n";
    })
    .filter(notNL)
    .concat(`! generated by rule-combiner ${timeStamp}`);

/**
 * Get remove rules from raw rules
 * @param {string[]} ss Raw Rules
 * @returns {string[]} remove rules
 */
const getRules = (ss) => ss.filter(isRule);

/**
 * Get style rules from raw rules
 * @param {string[]} ss Raw Rules
 * @returns {string[]} style rules
 */
const getStyles = (ss) => ss.filter(isStyle).map((s) => `${s}|`);

/**
 * Get style map from raw rules
 * @param {string[]} ss Raw Rules
 * @returns {Map<string, string>} Style Map
 */
const getStyleMap = (ss) => {
  const sMap = new Map();
  ss.forEach((s) => {
    const [k, v] = s.split(":style(");
    const ov = sMap.get(k) ?? [];
    sMap.set(k, [...ov, v.replaceAll(")|", "")]);
  });
  return sMap;
};

/**
 * Get combined styles from raw rules
 * @param {string[]} ss Raw Rules
 * @returns {string[]} Combined styles
 */
const getCombinedStyles = (ss) => {
  const sMap = getStyleMap(ss);
  return Array.from(sMap.keys()).map(
    (k) => `${k}:style(${(sMap.get(k) ?? []).join("; ")})`,
  );
};

/**
 * Get mobile header
 * @param {string} path Input file path
 * @returns {string} mobile header or empty string
 */
const getMobileHeader = (path) =>
  path.includes("mobile") ? "!#if env_mobile" : "";

/**
 * Get mobile footer
 * @param {string} path Input file path
 * @returns {string} mobile footer or empty string
 */
const getMobileFooter = (path) => (path.includes("mobile") ? "!#endif" : "");

/**
 * Get current timestamp
 * @returns {string} Current time string in ISO8601 format
 */
const getTimeStamp = () =>
  new Date(Date.now() - new Date().getTimezoneOffset() * 60000).toISOString();

/**
 * Get final processed rules
 * @param {string[]} ss Raw Rules
 * @param {string} path Input file path
 * @returns {string[]} output rules
 */
const getOutputRules = (ss, path) =>
  [
    ...getMeta(ss, getTimeStamp()),
    getMobileHeader(path),
    ...getRules(ss),
    ...getCombinedStyles(getStyles(ss)),
    getMobileFooter(path),
  ]
    .filter(Boolean)
    .join("\n")
    .concat("\n");

/**
 * Get output file path
 * @param {string} path Input file path
 * @returns {string} Output file path
 */
const getOutputFileName = (path) => `${path.split(".")[0]}.min.txt`;

/**
 * Combine rules for all input files
 * @param {string} d file directory
 * @param {string[]} ff Input files
 * @returns {Promise<string[][]>} Array<[Input File, Ouput file]>
 */
const combineRules = (d, ff) =>
  Promise.all(
    ff
      .map((f) => `${d}/${f}`)
      .map(async (f) => {
        const ss = await loadFile(f);
        const o = getOutputFileName(f);
        await Bun.write(o, getOutputRules(ss, f));
        return [f, o];
      }),
  );

/**
 * Add files to git
 * @param {string} d file directory
 * @param {string[][]} fo Array<[Input File, Ouput file]>
 */
const addRules = (d, fo) =>
  fo.map(([f, o]) => {
    Bun.spawnSync({
      cwd: d,
      cmd: ["git", "add", f],
    });
    Bun.spawnSync({
      cwd: d,
      cmd: ["git", "add", o],
    });
  });

/**
 * Make a git commit
 * @param {string} d file directory
 */
const commitRules = (d) =>
  Bun.spawnSync({
    cwd: d,
    cmd: ["git", "commit", "-qm", "feat: update ubo-rules by urb"],
  });

/**
 * Make a git push
 * @param {string} d file directory
 */
const pushRules = async (d) =>
  Bun.spawnSync({
    cwd: d,
    cmd: ["git", "push", "-q"],
  });

/**
 * Logger
 * @param {string} c contnt
 * @param {boolean} n with newline, default: `true`
 */
const logger = async (c, n = true) => {
  await Bun.write(Bun.stdout, `${c}${n ? "\n" : ""}`);
};

/**
 * main function
 */
const main = async () => {
  await logger("Update ubo-rules...", false);
  const d = Bun.argv[2];
  const fo = await combineRules(d, [
    "ubo-desktop.txt",
    "ubo-mobile.txt",
    "ubo-font.txt",
  ]);
  addRules(d, fo);
  commitRules(d);
  pushRules(d);
  await logger("done");
};

main();
