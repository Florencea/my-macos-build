/**
 * Check if current rule is `! comment`
 * @param {string} s
 * @returns {boolean}
 */
const isComment = (s) => s[0] === "!";

/**
 * Check if current rule is `:style()` rule
 * @param {string} s
 * @returns {boolean}
 */
const isStyle = (s) => s.includes(":style(");

/**
 * Check if current rule is remove rule
 * @param {string} s
 * @returns {boolean}
 */
const isRule = (s) => !isComment(s) && !isStyle(s);

/**
 * Check if current text not newline \n
 * @param {string} s
 * @returns {boolean}
 */
const notNL = (s) => s !== "\n";

/**
 * Check if current rule is `! Description:` comment
 * @param {string} s
 * @returns {boolean}
 */
const isDescription = (s) => s.includes("Description:");

/**
 * Check if current rule is `! Last updated:` comment
 * @param {string} s
 * @returns boolean
 */
const isLastUpdated = (s) => s.includes("Last updated:");

/**
 * Check if current rule is `! Title:` comment
 * @param {string} s
 * @returns {boolean}
 */
const isTitle = (s) => s.includes("Title:");

/**
 * load input file and split to lines
 * @param {string} path Input file path
 * @returns {Promise<string[]>}
 */
const loadFile = async (path) => {
  const s = await Bun.file(path).text();
  return s.split("\n").filter(notNL);
};

/**
 * Get meta comments from raw rules
 * @param {string[]} ss Raw Rules
 * @param {string} timeStamp Current time string in ISO8601 format
 * @returns {string[]} meta comments
 */
const getMeta = (ss, timeStamp) =>
  ss
    .map((s) => {
      return isTitle(s)
        ? `${s} minified`
        : isDescription(s) || isLastUpdated(s)
        ? s
        : "\n";
    })
    .filter(notNL)
    .concat(`! generated by rule-combiner ${timeStamp}`);

/**
 * Get remove rules from raw rules
 * @param {string[]} ss Raw Rules
 * @returns {string[]} remove rules
 */
const getRules = (ss) => ss.filter(isRule);

/**
 * Get style rules from raw rules
 * @param {string[]} ss Raw Rules
 * @returns {string[]} style rules
 */
const getStyles = (ss) => ss.filter(isStyle).map((s) => `${s}|`);

/**
 * Get style map from raw rules
 * @param {string[]} ss Raw Rules
 * @returns {Map<string, string>} Style Map
 */
const getStyleMap = (ss) => {
  const sMap = new Map();
  ss.forEach((s) => {
    const [k, v] = s.split(":style(");
    const ov = sMap.get(k) ?? [];
    sMap.set(k, [...ov, v.replaceAll(")|", "")]);
  });
  return sMap;
};

/**
 * Get combined styles from raw rules
 * @param {string[]} ss Raw Rules
 * @returns {string[]} Combined styles
 */
const getCombinedStyles = (ss) => {
  const sMap = getStyleMap(ss);
  return Array.from(sMap.keys()).map(
    (k) => `${k}:style(${(sMap.get(k) ?? []).join("; ")})`,
  );
};

/**
 * Get mobile header
 * @param {string} path Input file path
 * @returns {string} mobile header or empty string
 */
const getMobileHeader = (path) =>
  path.includes("mobile") ? "!#if env_mobile" : "";

/**
 * Get mobile footer
 * @param {string} path Input file path
 * @returns {string} mobile footer or empty string
 */
const getMobileFooter = (path) => (path.includes("mobile") ? "!#endif" : "");

/**
 * Get current timestamp
 * @returns {string} Current time string in ISO8601 format
 */
const getTimeStamp = () =>
  new Date(Date.now() - new Date().getTimezoneOffset() * 60000).toISOString();

/**
 * Get final processed rules
 * @param {string[]} ss Raw Rules
 * @param {string} path Input file path
 * @returns {string[]} output rules
 */
const getOutputRules = (ss, path) =>
  [
    ...getMeta(ss, getTimeStamp()),
    getMobileHeader(path),
    ...getRules(ss),
    ...getCombinedStyles(getStyles(ss)),
    getMobileFooter(path),
  ]
    .filter(Boolean)
    .join("\n")
    .concat("\n");

/**
 * Get output file path
 * @param {string} path Input file path
 * @returns {string} Output file path
 */
const getOutputFileName = (path) => `${path.split(".")[0]}.min.txt`;

/**
 * main function
 */
const main = async () => {
  const path = Bun.argv[2];
  const ss = await loadFile(path);
  await Bun.write(getOutputFileName(path), getOutputRules(ss, path));
};

main();
