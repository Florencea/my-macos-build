/**
 * Check if current line is `! comment`
 * @param line line to check
 */
const isComment = (line: string) => line[0] === "!";

/**
 * Check if current line is `:style()` rule
 * @param line line to check
 */
const isStyle = (line: string) => line.includes(":style(");

/**
 * Check if current line is remove rule
 * @param line line to check
 */
const isRule = (line: string) => !isComment(line) && !isStyle(line);

/**
 * Check if current text not newline \n
 * @param text text to check
 */
const notNL = (text: string) => text !== "\n";

/**
 * Check if current line is `! Description:` comment
 * @param line line to check
 */
const isDescription = (line: string) => line.includes("Description:");

/**
 * Check if current line is `! Last updated:` comment
 * @param line line to check
 */
const isLastUpdated = (line: string) => line.includes("Last updated:");

/**
 * Check if current line is `! Title:` comment
 * @param line line to check
 */
const isTitle = (line: string) => line.includes("Title:");

/**
 * load input file and split to lines
 * @param path Input file path
 */
const loadFile = async (path: string) => {
  const s = await Bun.file(path).text();
  return s.split("\n").filter(notNL);
};

/**
 * Get meta comments from lines
 * @param lines Lines
 * @param timeStamp Current time string in ISO8601 format
 * @returns meta comments
 */
const getMeta = (lines: string[], timeStamp: string) =>
  lines
    .map((line) => {
      return isTitle(line)
        ? `${line} minified`
        : isDescription(line) || isLastUpdated(line)
        ? line
        : "\n";
    })
    .filter(notNL)
    .concat(`! generated by rule-combiner ${timeStamp}`);

/**
 * Get remove rules from lines
 * @param lines Lines
 * @returns remove rules
 */
const getRules = (lines: string[]) => lines.filter(isRule);

/**
 * Get style rules from raw lines
 * @param lines Lines
 * @returns style rules
 */
const getStyles = (lines: string[]) =>
  lines.filter(isStyle).map((line) => `${line}|`);

/**
 * Get style map from lines
 * @param lines Lines
 * @returns Style Map
 */
const getStyleMap = (lines: string[]) => {
  const styleMap = new Map<string, string[]>();
  lines.forEach((line) => {
    const [entity, style] = line.split(":style(");
    const oldStyles = styleMap.get(entity) ?? [];
    styleMap.set(entity, [...oldStyles, style.replaceAll(")|", "")]);
  });
  return styleMap;
};

/**
 * Get combined styles from lines
 * @param lines Lines
 * @returns Combined styles
 */
const getCombinedStyles = (lines: string[]) => {
  const styleMap = getStyleMap(lines);
  return Array.from(styleMap.keys()).map(
    (entity) => `${entity}:style(${(styleMap.get(entity) ?? []).join("; ")})`,
  );
};

/**
 * Get mobile header
 * @param path Input file path
 * @returns mobile header or empty string
 */
const getMobileHeader = (path: string) =>
  path.includes("mobile") ? "!#if env_mobile" : "";

/**
 * Get mobile footer
 * @param path Input file path
 * @returns mobile footer or empty string
 */
const getMobileFooter = (path: string) =>
  path.includes("mobile") ? "!#endif" : "";

/**
 * Get current timestamp
 * @returns Current local time string in ISO8601 format
 */
const getTimeStamp = () =>
  new Date(Date.now() - new Date().getTimezoneOffset() * 60000).toISOString();

/**
 * Get final processed rule lines
 * @param lines Lines
 * @param path Input file path
 * @returns output line string
 */
const getOutputRules = (lines: string[], path: string) =>
  [
    ...getMeta(lines, getTimeStamp()),
    getMobileHeader(path),
    ...getRules(lines),
    ...getCombinedStyles(getStyles(lines)),
    getMobileFooter(path),
  ]
    .filter(Boolean)
    .join("\n")
    .concat("\n");

/**
 * Get output file path
 * @param path Input file path
 * @returns Output file path
 */
const getCombinedFilePath = (path: string) => `${path.split(".")[0]}.min.txt`;

/**
 * Combine rules for all input files
 * @param cwd current working directory
 * @param files Input file names
 * @returns Array<[Input file path, Combined file path]>
 */
const combineRules = (cwd: string, files: string[]) =>
  Promise.all(
    files
      .map((file) => `${cwd}/${file}`)
      .map(async (inputFilePath) => {
        const inputLines = await loadFile(inputFilePath);
        const combinedFilePath = getCombinedFilePath(inputFilePath);
        await Bun.write(
          combinedFilePath,
          getOutputRules(inputLines, inputFilePath),
        );
        return [inputFilePath, combinedFilePath];
      }),
  );

/**
 * Add files to git
 * @param cwd current working directory
 * @param filePairs Array<[Input file path, Combined file path]>
 */
const addRules = (cwd: string, filePairs: string[][]) =>
  filePairs.map(([inputFile, outputFile]) => {
    Bun.spawnSync({
      cwd,
      cmd: ["git", "add", inputFile],
    });
    Bun.spawnSync({
      cwd,
      cmd: ["git", "add", outputFile],
    });
  });

/**
 * Make a git commit
 * @param cwd current working directory
 */
const commitRules = (cwd: string) =>
  Bun.spawnSync({
    cwd,
    cmd: ["git", "commit", "-qm", "feat: update ubo-rules by urb"],
  });

/**
 * Make a git push
 * @param cwd current working directory
 */
const pushRules = async (cwd: string) =>
  Bun.spawnSync({
    cwd,
    cmd: ["git", "push", "-q"],
  });

/**
 * Single line logger
 * @param content content to print
 * @param withNewline print `\n` at content end, default: `true`
 */
const logger = async (content: string, withNewline: boolean = true) => {
  await Bun.write(Bun.stdout, `${content}${withNewline ? "\n" : ""}`);
};

/**
 * main function
 */
const main = async () => {
  await logger("Update ubo-rules...", false);
  const cwd = Bun.argv[2];
  const filePairs = await combineRules(cwd, [
    "ubo-desktop.txt",
    "ubo-mobile.txt",
    "ubo-font.txt",
  ]);
  addRules(cwd, filePairs);
  commitRules(cwd);
  pushRules(cwd);
  await logger("done");
};

main();
