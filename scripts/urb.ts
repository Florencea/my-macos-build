import { spawnSync } from "node:child_process";
import { readFileSync, writeFileSync } from "node:fs";
import { join, parse } from "node:path";
import { argv } from "node:process";

/**
 * Check if current line is `! comment`
 * @param line line to check
 */
const isComment = (line: string) => line[0] === "!";

/**
 * Check if current line is `:style()` rule
 * @param line line to check
 */
const isStyle = (line: string) => line.includes(":style(");

/**
 * Check if current line is remove rule
 * @param line line to check
 */
const isRule = (line: string) => !isComment(line) && !isStyle(line);

/**
 * Check if current text not newline \n
 * @param text text to check
 */
const notNL = (text: string) => text !== "\n";

/**
 * Check if current line is `! Description:` comment
 * @param line line to check
 */
const isDescription = (line: string) => line.includes("Description:");

/**
 * Check if current line is `! Last updated:` comment
 * @param line line to check
 */
const isLastUpdated = (line: string) => line.includes("Last updated:");

/**
 * Check if current line is `! Title:` comment
 * @param line line to check
 */
const isTitle = (line: string) => line.includes("Title:");

/**
 * load input file and split to lines
 * @param path Input file path
 */
const loadFile = (path: string) =>
  readFileSync(path, { encoding: "utf-8" }).split("\n").filter(notNL);

/**
 * Get meta comments from lines
 * @param lines Lines
 * @param timeStamp Current time string in ISO8601 format
 * @returns meta comments
 */
const getMeta = (lines: string[], timeStamp: string) =>
  lines
    .map((line) => {
      return isTitle(line)
        ? `${line} minified`
        : isDescription(line) || isLastUpdated(line)
        ? line
        : "\n";
    })
    .filter(notNL)
    .concat(`! generated by rule-combiner ${timeStamp}`);

/**
 * Get remove rules from lines
 * @param lines Lines
 * @returns remove rules
 */
const getRules = (lines: string[]) => lines.filter(isRule);

/**
 * Get style rules from raw lines
 * @param lines Lines
 * @returns style rules
 */
const getStyles = (lines: string[]) =>
  lines.filter(isStyle).map((line) => `${line}|`);

/**
 * Get style map from lines
 * @param lines Lines
 * @returns Style Map
 */
const getStyleMap = (lines: string[]) => {
  const styleMap = new Map<string, string[]>();
  lines.forEach((line) => {
    const [entity, style] = line.split(":style(");
    const oldStyles = styleMap.get(entity) ?? [];
    styleMap.set(entity, [...oldStyles, style.replaceAll(")|", "")]);
  });
  return styleMap;
};

/**
 * Get combined styles from lines
 * @param lines Lines
 * @returns Combined styles
 */
const getCombinedStyles = (lines: string[]) => {
  const styleMap = getStyleMap(lines);
  return Array.from(styleMap.keys()).map(
    (entity) => `${entity}:style(${(styleMap.get(entity) ?? []).join("; ")})`,
  );
};

/**
 * Get mobile header
 * @param path Input file path
 * @returns mobile header or empty string
 */
const getMobileHeader = (path: string) =>
  path.includes("mobile") ? "!#if env_mobile" : "";

/**
 * Get mobile footer
 * @param path Input file path
 * @returns mobile footer or empty string
 */
const getMobileFooter = (path: string) =>
  path.includes("mobile") ? "!#endif" : "";

/**
 * Get current timestamp
 * @returns Current local time string in ISO8601 format
 */
const getTimeStamp = () =>
  new Date(Date.now() - new Date().getTimezoneOffset() * 60000).toISOString();

/**
 * Get final processed rule lines
 * @param lines Lines
 * @param path Input file path
 * @returns output line string
 */
const getOutputRules = (lines: string[], path: string) =>
  [
    ...getMeta(lines, getTimeStamp()),
    getMobileHeader(path),
    ...getRules(lines),
    ...getCombinedStyles(getStyles(lines)),
    getMobileFooter(path),
  ]
    .filter(Boolean)
    .join("\n")
    .concat("\n");

/**
 * Get output file path
 * @param path Input file path
 * @returns Output file path
 */
const getCombinedFilePath = (path: string) => {
  const p = parse(path);
  return join(p.dir, `${p.name}.min.txt`);
};

/**
 * Combine rules for all input files
 * @param cwd current working directory
 * @param files Input file names
 * @returns Array<[Input file path, Combined file path]>
 */
const combineRules = (cwd: string, files: string[]) =>
  files
    .map((file) => join(cwd, file))
    .map((inputFilePath) => {
      const inputLines = loadFile(inputFilePath);
      const combinedFilePath = getCombinedFilePath(inputFilePath);
      writeFileSync(
        combinedFilePath,
        getOutputRules(inputLines, inputFilePath),
      );
      return [inputFilePath, combinedFilePath];
    });

/**
 * Add files to git
 * @param cwd current working directory
 * @param filePairs Array<[Input file path, Combined file path]>
 */
const addRules = (cwd: string, filePairs: string[][]) => {
  filePairs.map(([inputFile, outputFile]) => {
    spawnSync("git", ["add", inputFile], { cwd });
    spawnSync("git", ["add", outputFile], { cwd });
  });
};

/**
 * Make a git commit
 * @param cwd current working directory
 */
const commitRules = (cwd: string) => {
  spawnSync("git", ["commit", "-qm", "feat: update ubo-rules by urb"], { cwd });
};

/**
 * Make a git push
 * @param cwd current working directory
 */
const pushRules = (cwd: string) => {
  spawnSync("git", ["push", "-q"], { cwd });
};

/**
 * main function
 */
const main = () => {
  const cwd = argv[2];
  const filePairs = combineRules(cwd, [
    "ubo-desktop.txt",
    "ubo-mobile.txt",
    "ubo-font.txt",
  ]);
  addRules(cwd, filePairs);
  commitRules(cwd);
  pushRules(cwd);
};

main();
