const isComment = (s: string) => s[0] === "!";

const isStyle = (s: string) => s.includes(":style(");

const isRule = (s: string) => !isComment(s) && !isStyle(s);

const notNL = (s: string) => s !== "\n";

const isDescription = (s: string) => s.includes("Description:");

const isLastUpdated = (s: string) => s.includes("Last updated:");

const isTitle = (s: string) => s.includes("Title:");

const loadFile = async (path: string) => {
  const s = await Deno.readTextFile(path);
  return s.split("\n").filter(notNL);
};

const getMeta = (ss: string[], timeStamp: string) =>
  ss
    .map((s) => {
      return isTitle(s)
        ? `${s} minified`
        : isDescription(s) || isLastUpdated(s)
        ? s
        : "\n";
    })
    .filter(notNL)
    .concat(`! generated by rule-combiner ${timeStamp}`);

const getRules = (ss: string[]) => ss.filter(isRule);

const getStyles = (ss: string[]) => ss.filter(isStyle).map((s) => `${s}|`);

const getStyleMap = (ss: string[]) => {
  const sMap = new Map<string, string[]>();
  ss.forEach((s) => {
    const [k, v] = s.split(":style(");
    const ov = sMap.get(k) ?? [];
    sMap.set(k, [...ov, v.replaceAll(")|", "")]);
  });
  return sMap;
};

const getCombinedStyles = (ss: string[]) => {
  const sMap = getStyleMap(ss);
  return Array.from(sMap.keys()).map(
    (k) => `${k}:style(${(sMap.get(k) ?? []).join("; ")})`,
  );
};

const getMobileHeader = (path: string) =>
  path.includes("mobile") ? "!#if env_mobile" : "";

const getMobileFooter = (path: string) =>
  path.includes("mobile") ? "!#endif" : "";

const getTimeStamp = () =>
  new Date(Date.now() - new Date().getTimezoneOffset() * 60000).toISOString();

const getOutputRules = (ss: string[], path: string) =>
  [
    ...getMeta(ss, getTimeStamp()),
    getMobileHeader(path),
    ...getRules(ss),
    ...getCombinedStyles(getStyles(ss)),
    getMobileFooter(path),
  ]
    .filter(Boolean)
    .join("\n")
    .concat("\n");

const getOutputFileName = (path: string) => `${path.split(".")[0]}.min.txt`;

const main = async () => {
  const path = Deno.args[0];
  const ss = await loadFile(path);
  await Deno.writeTextFile(getOutputFileName(path), getOutputRules(ss, path));
};

main();
